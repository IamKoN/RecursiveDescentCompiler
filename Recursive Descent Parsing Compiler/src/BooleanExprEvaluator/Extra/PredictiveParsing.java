/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package BooleanExprEvaluator.Extra;

-- lookahead is a global variable
 
  procedure scan(var t : token){
    -- get the next token from the input stream}

  procedure match (t : token){ 
   if (t = lookahead){  // a match has been made
      scan(lookahead)           // get new lookahead
   else
      error(t)                  // report an error,e.g."t expected"
    }
}

  procedure idlist (){
    match(id)      //  -- an idlist must start with an identifier
    if lookahead = comma { //  -- another identifier follows
       match(comma)
       idlist()
    }
}

  procedure field   -- parse a record field
  begin
    idlist
    match(colon)
    type
  end field

  procedure fields  
  begin
    field
    if lookahead = semicolon then
      match(semicolon)
      fields
    endif
  end fields

  procedure type
  begin
    case lookahead of 
       recordsym :  match(recordsym)
                    fields
                    match(endsym)
       arraysym  :  match(arraysym)
                    match(lbracket)
                    simple
                    match(rbracket)
                    match(ofsym)
                    type
       lparen    :  match(lparen)
                    idlist
                    match(rparen)
       otherwise    simple
    end case
  end type

  procedure simple;
  begin
    case lookahead of
        intsym  : match(intsym)
        charsym : match(charsym)
        num     : match(num)
                  match(dotdot)
                  match(num)
        otherwise error
    end case
  end simple

  predictive parsing relies on information about what first symbols 
  can be generated by the right side of a production.  

  FIRST(s) -- set of tokens that appear as the first symbols of one 
  or more strings generated from s.  
  FIRST(simple) = { intsym, num, charsym }
        FIRST(type) = { arraysym, recsym, lparen, intsym, num, charsym }

  Predictive parsing requires that if there are two productions 
    A --> r   and  A --> s then  FIRST(r) and FIRST(s) are disjoint.
  Otherwise, backtracking will be required.

Left Recursion

  Left recursion will result in an infinite loop

  To remove left recursion, e.g.,

    A --> A & | @     & and @ are sequences of tokens/nonterminals

  the only way to stop the recursion is to match A with @.
  Thus, we must have @ followed by 0 or more &'s

  solution:
    A --> @ R
    R --> & R | e     (right recursive)

A TRANSLATOR FOR SIMPLE EXPRESSIONS

   Example:
        expr --> expr + term | expr - term | term    

    transform to:     
        expr --> term rest
        rest --> + term rest | - term rest | e

   or
        expr -->  expr + term {print '+'} 
                | expr - term {print '-'}
                | term    
        term --> 0 {print '0'} | ... | 9 {print '9'}

    transform to:     
        expr -->  term rest
        rest -->  + term {print '+'} rest 
                | - term {print '-'} rest 
                | e
        term --> 0 {print '0'} | ... | 9 {print '9'}



   procedure term
    begin
      if lookahead is a digit then 
        write the digit
        match(lookahead)
      else
        error(lookahead)
      endif
    end term

   procedure rest
    begin
      case 
        lookahead = plus_symbol :
            match(plus_symbol)
            term
            write('+')
            rest
        lookahead = minus_symbol :
            match(minus_symbol)
            term
            write('-')
            rest
        otherwise    -- do nothing; rest is empty string
      endcase
    end rest

   procedure expr
    begin
      term
      rest
    end expr

Optimizing the Translator

   -- eliminate tail recursion (right recursion) by replacing with 
        iteration (this is usually very easy to do)

   procedure rest
    begin
     while lookahead in {plus_symbol, minus_symbol} do
      case 
        lookahead = plus_symbol :
            match(plus_symbol)
            term
            write('+')
        lookahead = minus_symbol :
            match(minus_symbol)
            term
            write('-')
      endcase
     endwhile
    end rest

   Now, because the only call to rest comes in expr, we can put the 
   above code directly in expr and eliminate the procedure.  This 
   corresponds to the extended BNF

     expr --> term { (+|-) term }   ({ } means 0 or more times)

   procedure term
    begin
      if lookahead is a digit then 
        write the digit
        match(lookahead)
      else
        error(lookahead)
      endif
    end term

   procedure expr
    begin
      term
      case 
        lookahead = plus_symbol :
            match(plus_symbol)
            term
            write('+')
            rest
        lookahead = minus_symbol :
            match(minus_symbol)
            term
            write('-')
            rest
        otherwise    -- do nothing; rest is empty string
      endcase
    end expr
